{
  "language": "Solidity",
  "sources": {
    "contracts/esusu.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract Esusu {\r\n\r\n\r\n    // VARIABLES\r\n\r\n    // track the groupcount and userCount\r\n    uint public groupCount = 0;\r\n    uint public userCount = 0;\r\n\r\n    // create a list of groups and users\r\n    Group[]public groupList;\r\n    EsusuUser[] public userList;\r\n\r\n    // create the admin (owner)\r\n    struct AdminOwner {\r\n        address payable adminAddress;\r\n        uint adminBalance;\r\n        uint adminNextPaymentAmount;\r\n    }\r\n\r\n    // create a user\r\n    struct EsusuUser {\r\n        address payable userAddress;\r\n        uint userBalance;\r\n    }\r\n\r\n    // create a groupMember\r\n    struct GroupMember {\r\n        address payable userAddress;\r\n        uint nextPaymentDate;\r\n        uint nextPaymentAmount;\r\n        uint lastPaymentAmount;\r\n        uint[] completedDonationRounds;\r\n    }\r\n\r\n    // create a group\r\n    struct Group {\r\n        uint id;\r\n        string groupName;\r\n        uint groupBuyInAmount;\r\n        address payable groupCoordinator;\r\n        uint groupBalance;\r\n        uint groupActivationTime;\r\n    }\r\n\r\n    // create a donation\r\n    struct GroupDonation {\r\n        Group group;\r\n        uint donationRound;\r\n        uint donationStartTime;\r\n        uint donationEndTime;\r\n        uint latePaymentStartTime;\r\n        uint latePaymentEndTime;\r\n    }\r\n\r\n\r\n\r\n    // CONSTRUCTOR WITH MAPPING OF ADDRESS TO ADMIN\r\n\r\n    // mapping between groupId and donation rounds\r\n    mapping (uint => GroupDonation[]) groupDonations;\r\n\r\n    // create a mapping between groups and groupmembers (name)\r\n    mapping (string => GroupMember[]) groupinfo;\r\n\r\n    // create a mapping between groups and groupmembers (id)\r\n    mapping (uint => GroupMember[]) groupinfo_i;\r\n\r\n    // mapping between group id and list of groupmembers\r\n    mapping (uint => GroupMember[]) groupMemberDict;\r\n\r\n    // mapping between group index and group\r\n    mapping (uint => Group) groupDict;\r\n\r\n    // mapping between address and groupmembers\r\n    mapping (address => Group[]) userGroups;\r\n\r\n    // mapping between user profile and user address\r\n    mapping (address => EsusuUser) userProfile;\r\n\r\n\r\n    // EVENTS\r\n    event createGroupEvent(address _groupCoordinator, Group _group, uint cbalance);\r\n    event newGroupMemberEvent(address _groupMember, Group _group, uint cbalance);\r\n    event groupActivationEvent(Group _group, uint _groupActivationTime, uint cbalance);\r\n    event payGroupMemberEvent(Group _group, GroupMember _groupMember, uint _paymentAmount, uint _paymentTime, uint cbalance);\r\n    event userWithdrawalEvent(EsusuUser _user, uint _withdrawalAmount, uint _withdrawalTime, uint cbalance);\r\n    event createUserProfileEvent(address _userAddress, EsusuUser _userProfile, uint _userCreationTime, uint cbalance);\r\n\r\n\r\n\r\n\r\n    // FUNCTIONS\r\n\r\n    // function to get a user profile\r\n    function getUserProfile() public view returns(EsusuUser memory) {\r\n        require(userProfile[msg.sender].userAddress == msg.sender, \"Create an EsusuUser account to view profile\");\r\n        \r\n        EsusuUser storage userprofile = userProfile[msg.sender];\r\n        return userprofile;\r\n    }\r\n\r\n\r\n\r\n\r\n    // function to get a user's droups\r\n    function getUserGroups() public view returns(Group[] memory) {\r\n        require(userProfile[msg.sender].userAddress == msg.sender, \"Create an EsusuUser account to access this functionality\");\r\n\r\n        Group[] storage usergroups = userGroups[msg.sender];\r\n        return usergroups;\r\n    }\r\n\r\n\r\n\r\n\r\n    // function to create a user profile\r\n    function createUserProfile() public {\r\n\r\n        require(userProfile[msg.sender].userAddress != msg.sender, \"You are already a user\");\r\n\r\n        EsusuUser memory userprofile = EsusuUser(payable(msg.sender), 0);\r\n        userList.push(userprofile);\r\n        userCount += 1;\r\n        userProfile[msg.sender] = userprofile;\r\n\r\n\r\n        // subscribe to events\r\n        emit createUserProfileEvent(msg.sender, userprofile, block.timestamp, address(this).balance);\r\n    }\r\n\r\n\r\n    // function to create a group\r\n    function createGroup(string memory groupName, uint groupBuyInAmount) payable public {\r\n\r\n        // validate (...??how do i get buyinamount == msg.value??)\r\n        require(groupBuyInAmount >= 5, \"error\" );\r\n        require(msg.value >= 5 ether, \"ether error\");\r\n        require(userProfile[msg.sender].userAddress == msg.sender, \"Create an EsusuUser account to create a group\");\r\n        \r\n        // create a group by paying in\r\n        if(!payable(msg.sender).send(groupBuyInAmount)) {\r\n            revert(\"Unable to transfer buyIn funds\");\r\n        }\r\n\r\n        // increase group count\r\n        groupCount += 1;\r\n\r\n        // create a groupMember object\r\n        uint[] memory groupMemberDonations;\r\n        GroupMember memory groupMember = GroupMember(payable(msg.sender), 0, 0, 0, groupMemberDonations);\r\n\r\n        // create the group object\r\n        Group storage group = groupDict[groupCount];\r\n        groupMemberDict[groupCount].push(groupMember);\r\n        \r\n        group.id = groupCount;\r\n        group.groupName = groupName;\r\n        group.groupBuyInAmount = groupBuyInAmount;\r\n        group.groupCoordinator = payable(msg.sender);\r\n        group.groupBalance = groupBuyInAmount;\r\n        group.groupActivationTime = 0;\r\n\r\n        // add to the list of groups\r\n        groupList.push(group);\r\n\r\n        // add the group to the user's groups\r\n        userGroups[msg.sender].push(group);\r\n\r\n        // add groupmember to group\r\n        groupinfo[group.groupName].push(groupMember);\r\n        groupinfo_i[groupCount].push(groupMember);\r\n\r\n        // subscribe to the events\r\n        emit createGroupEvent(group.groupCoordinator, group, address(this).balance);\r\n        emit newGroupMemberEvent(msg.sender, group, address(this).balance);\r\n    }\r\n\r\n\r\n\r\n\r\n    // function to get a group by the group id\r\n    function getGroupbyId(uint groupId)  public view returns(Group memory, GroupMember[] memory, GroupDonation[] memory) {\r\n\r\n        require(userProfile[msg.sender].userAddress == msg.sender, \"You have to be an EsusuUser to get this information\");\r\n\r\n        // returns the group info and members in the group\r\n        Group storage group = groupDict[groupId];\r\n        GroupMember[] storage groupMembers = groupinfo_i[groupId];\r\n        GroupDonation[] storage groupdonations = groupDonations[groupId];\r\n        return (group, groupMembers, groupdonations);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    // function to join a group\r\n    function joinGroup(uint groupId) payable public {\r\n\r\n        require(userProfile[msg.sender].userAddress == msg.sender, \"Create an EsusuUser account to join a group\");\r\n\r\n        // get the group \r\n        Group storage group = groupDict[groupId];\r\n\r\n        // validate group buyin amount\r\n        require(msg.value >= 5 ether);\r\n\r\n        // get the number of members in the group\r\n        GroupMember[] storage groupMembers = groupinfo_i[groupId];\r\n        if (groupMembers.length >= 6) {\r\n            revert(\"Sorry, this group is maxed out\");\r\n        }\r\n\r\n        for (uint i=0; i<groupMembers.length; i++) {\r\n            if (groupMembers[i].userAddress == msg.sender) {\r\n                revert(\"User already belongs to this group\");\r\n            }\r\n        }\r\n\r\n        // validate payment\r\n        if(!payable(msg.sender).send(group.groupBuyInAmount)) {\r\n            revert(\"Unable to transfer buyIn funds\");\r\n        }\r\n\r\n        // create a groupMember profile\r\n        uint[] memory groupMemberDonations;\r\n        GroupMember memory groupMember = GroupMember(payable(msg.sender), 0, 0, 0, groupMemberDonations);\r\n\r\n        // add the group to the user's groups\r\n        userGroups[msg.sender].push(group);\r\n\r\n        // add groupmember to group\r\n        groupinfo[group.groupName].push(groupMember);\r\n        groupinfo_i[groupCount].push(groupMember);\r\n\r\n        // increase the balance in the group\r\n        group.groupBalance += group.groupBuyInAmount;\r\n\r\n        // subscribe to events\r\n        emit newGroupMemberEvent(msg.sender, group, address(this).balance);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    // function to activate group and store member payout amounts and dates\r\n    function activateGroup(uint groupId) public {\r\n\r\n        // get the group and groupmembers\r\n        Group storage group = groupDict[groupId];\r\n        GroupMember[] storage groupMembers = groupinfo_i[groupId];\r\n\r\n        // validate\r\n        if (msg.sender != group.groupCoordinator) {\r\n            revert(\"You are not the coordinator of this group\");\r\n        }\r\n\r\n        if (groupMembers.length != 6) {\r\n            revert(\"The group is incomplete\");\r\n        }\r\n\r\n        if (group.groupActivationTime != 0) {\r\n            revert(\"This group is already active\");\r\n        }\r\n\r\n        // set group activation time\r\n        group.groupActivationTime = block.timestamp;\r\n        emit groupActivationEvent(group, group.groupActivationTime, address(this).balance);\r\n\r\n        // set the current donation round\r\n        uint donationRound = 2;\r\n        // set a pointer for donation rounds algorithm\r\n        uint donationRoundsTimer = group.groupActivationTime;\r\n\r\n        // set the group donation rounds\r\n        for (uint j=1; j<groupMembers.length; j++) {\r\n            // create GroupDonation\r\n            uint donationRoundStartTime = donationRoundsTimer;\r\n\r\n            // set the donation timer for 2 weeks (14 days)\r\n            uint donationRoundEndTime = donationRoundStartTime + 1209600;\r\n\r\n            // set a timer for late donations (5 days)\r\n            uint lateDonationStartTime = donationRoundEndTime;\r\n            uint lateDonationEndTime = lateDonationStartTime + 432000;\r\n\r\n            // save the group donation rounds\r\n            GroupDonation memory groupdonation = GroupDonation(group, donationRound, donationRoundStartTime, donationRoundEndTime, lateDonationStartTime, lateDonationEndTime);\r\n\r\n            // add to the mapping for groups and groupdonations\r\n            groupDonations[groupId].push(groupdonation);\r\n\r\n            // update the donationRoundsTimer for 27 days (1 month)\r\n            donationRoundsTimer += 2332800;\r\n\r\n            // increase the donations round\r\n            donationRound += 1;\r\n        }\r\n\r\n\r\n        // set next payout and payout amounts for groupmembers\r\n        for (uint i=0; i<groupMembers.length; i++) {\r\n            \r\n            GroupMember storage groupMember = groupMembers[i];\r\n\r\n            // set the groupmember's next payout date\r\n            groupMember.nextPaymentDate = group.groupActivationTime + 2332800;\r\n        \r\n            // TODO: ADMIN SHARE\r\n        \r\n            // set the payout amount (1/2 for late payment penalties and in case of missed future payments)\r\n            groupMember.nextPaymentAmount = ((group.groupBuyInAmount * 6) - group.groupBuyInAmount) / 2;\r\n            \r\n            // save the amount to be paid at the end of the saving cycle\r\n            groupMember.lastPaymentAmount = groupMember.nextPaymentAmount;\r\n\r\n            // updte the group activation time (it is the counter used to calculate the payout algorithm)\r\n            group.groupActivationTime = groupMember.nextPaymentDate;\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    // function to pay groupmember if it is the user's turn\r\n    function payGroupMember(uint groupId) public {\r\n\r\n        // get the group and groupmembers\r\n        Group storage group = groupDict[groupId];\r\n        GroupMember[] storage groupMembers = groupinfo_i[groupId];\r\n\r\n        // validate\r\n        if (msg.sender != group.groupCoordinator) {\r\n            revert(\"You are not the coordinator of this group\");\r\n        }\r\n        if (groupMembers.length != 6) {\r\n            revert(\"The group is incomplete\");\r\n        }\r\n\r\n        // look for the person to be paid\r\n        for (uint i=0; i<groupMembers.length; i++) {\r\n            \r\n            // get the groupmember and groupmember user profile\r\n            GroupMember storage groupMember = groupMembers[i];\r\n            EsusuUser storage userprofile = userProfile[groupMember.userAddress];\r\n            \r\n            // get the groupmember's next payout amount\r\n            uint paymentAmount = groupMember.nextPaymentAmount;\r\n\r\n            // check if his payment is valid\r\n            if (block.timestamp >= groupMember.nextPaymentDate) {\r\n                if (paymentAmount > 0) {\r\n\r\n                    // payout \r\n                    userprofile.userBalance += paymentAmount;\r\n                    \r\n                    // subscribe to events\r\n                    emit payGroupMemberEvent(group, groupMember, paymentAmount, block.timestamp, address(this).balance);\r\n                    \r\n                    // update the groupmember's payment amount\r\n                    groupMember.nextPaymentAmount = 0;\r\n                    group.groupBalance -= groupMember.nextPaymentAmount;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    // function for users to withdraw funds\r\n    function userWithdrawal() public payable {\r\n\r\n        require(userProfile[msg.sender].userAddress == msg.sender, \"Create an EsusuUser account to access this function\");\r\n\r\n        // get the user profile\r\n        EsusuUser storage userprofile = userProfile[msg.sender];\r\n\r\n        // check that the user has funds \r\n        if (userprofile.userBalance > 0) {\r\n\r\n            // since we deal in ether, convert the funds to be withdrawn to ether\r\n            uint withdrawalAmount = userprofile.userBalance * (1 ether);\r\n\r\n            // pay the user\r\n            if (payable(msg.sender).send(withdrawalAmount)) {\r\n                userprofile.userBalance = 0;\r\n\r\n                // subscribe to events\r\n                emit userWithdrawalEvent(userprofile, userprofile.userBalance, block.timestamp, address(this).balance);\r\n            } else {\r\n                revert(\"Unable to pay\");\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    // function to collect group donations\r\n    function userDonation(uint groupId, uint donationRound) public payable {\r\n\r\n        // get the group and groupmembers and groupdonations\r\n        Group storage group = groupDict[groupId];\r\n        GroupMember[] storage groupMembers = groupinfo_i[groupId];\r\n        GroupDonation[] storage groupdonations = groupDonations[groupId];\r\n\r\n        // validate\r\n        if (groupMembers.length != 6) {\r\n            revert(\"The group is incomplete\");\r\n        }\r\n\r\n        // get the amount to be paid for donation\r\n        uint donationAmount = group.groupBuyInAmount * (1 ether);\r\n\r\n        // validate payment amount\r\n        if (msg.value < donationAmount) {\r\n            revert(\"group payment should be group buy in amount\");\r\n        }\r\n\r\n        // ensure the donator is a member of the group and has not paid for that round\r\n        bool isGroupMember = false;\r\n        for (uint i=0; i<groupMembers.length; i++) {\r\n            if (groupMembers[i].userAddress == msg.sender) {\r\n\r\n                // get the groupmember\r\n                GroupMember storage groupmember = groupMembers[i];\r\n\r\n                // check if the user has already donated for the donation round requested for\r\n                for (uint k=0; k<groupmember.completedDonationRounds.length; k++) {\r\n                    if (groupmember.completedDonationRounds[k] == donationRound) {\r\n                        revert(\"You have already donated for this round\");\r\n                    }\r\n                }\r\n                isGroupMember = true;\r\n            }\r\n        }\r\n\r\n        // get the donation round requested for\r\n        GroupDonation memory selectedDonationRound;\r\n        bool isFound_selectedDonationRound = false;\r\n        if (isGroupMember == true) {\r\n            // get the group donation round that was requested\r\n            for (uint j=0; j<groupdonations.length; j++) {\r\n                if (groupdonations[j].donationRound == donationRound) {\r\n                    selectedDonationRound = groupdonations[j];\r\n                    isFound_selectedDonationRound = true;\r\n                }\r\n            }\r\n        } else {\r\n            revert(\"You are not a member of this group\");\r\n        }\r\n\r\n        // check that the round is still valid\r\n        if (isFound_selectedDonationRound == true) {\r\n            if (block.timestamp >= selectedDonationRound.donationStartTime && block.timestamp <= selectedDonationRound.donationEndTime) {\r\n\r\n                // pay the donation\r\n                if(!payable(msg.sender).send(group.groupBuyInAmount)) {\r\n                    revert(\"Unable to transfer donation funds\");\r\n                }\r\n\r\n                // increase the group balance\r\n                group.groupBalance += group.groupBuyInAmount;\r\n\r\n                // add the donation round to users completed list\r\n                for (uint m=0; m<groupMembers.length; m++) {\r\n                    if (groupMembers[m].userAddress == msg.sender) {\r\n                        GroupMember storage groupmember = groupMembers[m];\r\n                        groupmember.completedDonationRounds.push(donationRound);\r\n                    }\r\n                }\r\n            \r\n            } else if (block.timestamp < selectedDonationRound.donationStartTime) {\r\n                revert(\"This group round is not active yet\");\r\n            } else {\r\n                revert(\"This group round is expired\");\r\n            }\r\n        } else {\r\n            revert(\"no group round of that choice\");\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    // function to accept late donations\r\n    function lateDonation(uint groupId, uint donationRound) public payable {\r\n\r\n        // get the group and groupmembers and groupdonations\r\n        Group storage group = groupDict[groupId];\r\n        GroupMember[] storage groupMembers = groupinfo_i[groupId];\r\n        GroupDonation[] storage groupdonations = groupDonations[groupId];\r\n\r\n        // validate\r\n        if (groupMembers.length != 6) {\r\n            revert(\"The group is incomplete\");\r\n        }\r\n\r\n        // get the donation amount\r\n        uint donationAmount = group.groupBuyInAmount * (1 ether);\r\n\r\n        if (msg.value < donationAmount) {\r\n            revert(\"group payment should be group buy in amount\");\r\n        }\r\n\r\n        // ensure the donator is a member of the group and has not paid for that round\r\n        bool isGroupMember = false;\r\n        for (uint i=0; i<groupMembers.length; i++) {\r\n            if (groupMembers[i].userAddress == msg.sender) {\r\n\r\n                // get the groupmember\r\n                GroupMember storage groupmember = groupMembers[i];\r\n\r\n                // check if the user has already donated for the donation round requested for\r\n                for (uint k=0; k<groupmember.completedDonationRounds.length; k++) {\r\n                    if (groupmember.completedDonationRounds[k] == donationRound) {\r\n                        revert(\"You have already donated for this round\");\r\n                    }\r\n                }\r\n                isGroupMember = true;\r\n            }\r\n        }\r\n\r\n        // get the donation round requested for\r\n        GroupDonation memory selectedDonationRound;\r\n        bool isFound_selectedDonationRound = false;\r\n        if (isGroupMember == true) {\r\n            // get the group donation round that was requested\r\n            for (uint j=0; j<groupdonations.length; j++) {\r\n                if (groupdonations[j].donationRound == donationRound) {\r\n                    selectedDonationRound = groupdonations[j];\r\n                    isFound_selectedDonationRound = true;\r\n                }\r\n            }\r\n        } else {\r\n            revert(\"You are not a member of this group\");\r\n        }\r\n\r\n        // check that the round is still valid for late payment\r\n        if (isFound_selectedDonationRound == true) {\r\n            if (block.timestamp >= selectedDonationRound.latePaymentStartTime && block.timestamp <= selectedDonationRound.latePaymentEndTime) {\r\n\r\n                // pay the donation\r\n                if(!payable(msg.sender).send(group.groupBuyInAmount)) {\r\n                    revert(\"Unable to transfer donation funds\");\r\n                }\r\n\r\n                // increase the group balance\r\n                group.groupBalance += group.groupBuyInAmount;\r\n\r\n                // add the donation round to users completed list\r\n                for (uint m=0; m<groupMembers.length; m++) {\r\n                    if (groupMembers[m].userAddress == msg.sender) {\r\n                        GroupMember storage groupmember = groupMembers[m];\r\n                        groupmember.completedDonationRounds.push(donationRound);\r\n\r\n                        // add the penalty for late payment\r\n                        groupmember.lastPaymentAmount -= group.groupBuyInAmount / 2;\r\n                    }\r\n                }\r\n            \r\n            } else if (block.timestamp < selectedDonationRound.donationStartTime) {\r\n                revert(\"The late payment for this group round is not active yet\");\r\n            } else {\r\n                revert(\"The late payment for thsi group round is expired\");\r\n            }\r\n        } else {\r\n            revert(\"no group round of this choice\");\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}